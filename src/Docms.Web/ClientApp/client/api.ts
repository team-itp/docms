/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * DocMS API
 * Document Management System for small companies Web API
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost".replace(/\/+$/, "");

const object_assign = function assign(target: any, ... varArgs: any[]) { // .length of function is 2
    'use strict';
    if (target == null) { // TypeError if undefined or null
        throw new TypeError('Cannot convert undefined or null to object');
    }

    var to = Object(target);

    for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];

        if (nextSource != null) { // Skip over if undefined or null
            for (var nextKey in nextSource) {
                // Avoid bugs when hasOwnProperty is shadowed
                if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                    to[nextKey] = nextSource[nextKey];
                }
            }
        }
    }
    return to;
};


/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration?: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = 'RequiredError';
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface CreateTagRequest
 */
export interface CreateTagRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateTagRequest
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateTagRequest
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface DocumentLinks
 */
export interface DocumentLinks {
    /**
     * 
     * @type {Link}
     * @memberof DocumentLinks
     */
    file?: Link;
    /**
     * 
     * @type {Link}
     * @memberof DocumentLinks
     */
    self?: Link;
}

/**
 * 
 * @export
 * @interface DocumentResponse
 */
export interface DocumentResponse {
    /**
     * 
     * @type {number}
     * @memberof DocumentResponse
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DocumentResponse
     */
    mediaType?: string;
    /**
     * 
     * @type {number}
     * @memberof DocumentResponse
     */
    size?: number;
    /**
     * 
     * @type {string}
     * @memberof DocumentResponse
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentResponse
     */
    path?: string;
    /**
     * 
     * @type {Array&lt;TagResponse&gt;}
     * @memberof DocumentResponse
     */
    tags?: Array<TagResponse>;
    /**
     * 
     * @type {DocumentLinks}
     * @memberof DocumentResponse
     */
    links?: DocumentLinks;
}

/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    href?: string;
}

/**
 * 
 * @export
 * @interface SearchResponse
 */
export interface SearchResponse {
    /**
     * 
     * @type {Array&lt;TagResponse&gt;}
     * @memberof SearchResponse
     */
    searchTags?: Array<TagResponse>;
    /**
     * 
     * @type {Array&lt;DocumentResponse&gt;}
     * @memberof SearchResponse
     */
    documents?: Array<DocumentResponse>;
}

/**
 * 
 * @export
 * @interface TagLinks
 */
export interface TagLinks {
    /**
     * 
     * @type {Link}
     * @memberof TagLinks
     */
    self?: Link;
}

/**
 * 
 * @export
 * @interface TagResponse
 */
export interface TagResponse {
    /**
     * 
     * @type {number}
     * @memberof TagResponse
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TagResponse
     */
    title?: string;
    /**
     * 
     * @type {TagLinks}
     * @memberof TagResponse
     */
    links?: TagLinks;
}

/**
 * 
 * @export
 * @interface UploadDocumentRequest
 */
export interface UploadDocumentRequest {
    /**
     * 
     * @type {string}
     * @memberof UploadDocumentRequest
     */
    mediaType?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadDocumentRequest
     */
    encoding?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadDocumentRequest
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadDocumentRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadDocumentRequest
     */
    path?: string;
    /**
     * 
     * @type {Array&lt;TagResponse&gt;}
     * @memberof UploadDocumentRequest
     */
    tags?: Array<TagResponse>;
}


/**
 * DocumentsApi - fetch parameter creator
 * @export
 */
export const DocumentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentsByIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling apiDocumentsByIdDelete.');
            }
            const localVarPath = `/api/Documents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = object_assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Bearer", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = object_assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = object_assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentsByIdGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling apiDocumentsByIdGet.');
            }
            const localVarPath = `/api/Documents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = object_assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Bearer", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = object_assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = object_assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UploadDocumentRequest} [document] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentsByIdPut(id: number, document?: UploadDocumentRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling apiDocumentsByIdPut.');
            }
            const localVarPath = `/api/Documents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = object_assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Bearer", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = object_assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = object_assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(document || {});

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentsGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/Documents`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = object_assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Bearer", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = object_assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = object_assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UploadDocumentRequest} [document] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentsPost(document?: UploadDocumentRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Documents`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = object_assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Bearer", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = object_assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = object_assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(document || {});

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentsByIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).apiDocumentsByIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentsByIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DocumentResponse> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).apiDocumentsByIdGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UploadDocumentRequest} [document] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentsByIdPut(id: number, document?: UploadDocumentRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).apiDocumentsByIdPut(id, document, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DocumentResponse>> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).apiDocumentsGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UploadDocumentRequest} [document] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentsPost(document?: UploadDocumentRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).apiDocumentsPost(document, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentsByIdDelete(id: number, options?: any) {
            return DocumentsApiFp(configuration).apiDocumentsByIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentsByIdGet(id: number, options?: any) {
            return DocumentsApiFp(configuration).apiDocumentsByIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {UploadDocumentRequest} [document] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentsByIdPut(id: number, document?: UploadDocumentRequest, options?: any) {
            return DocumentsApiFp(configuration).apiDocumentsByIdPut(id, document, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentsGet(options?: any) {
            return DocumentsApiFp(configuration).apiDocumentsGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {UploadDocumentRequest} [document] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentsPost(document?: UploadDocumentRequest, options?: any) {
            return DocumentsApiFp(configuration).apiDocumentsPost(document, options)(fetch, basePath);
        },
    };
};

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI {
    /**
     * 
     * @param {} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public apiDocumentsByIdDelete(id: number, options?: any) {
        return DocumentsApiFp(this.configuration).apiDocumentsByIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public apiDocumentsByIdGet(id: number, options?: any) {
        return DocumentsApiFp(this.configuration).apiDocumentsByIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} id 
     * @param {} [document] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public apiDocumentsByIdPut(id: number, document?: UploadDocumentRequest, options?: any) {
        return DocumentsApiFp(this.configuration).apiDocumentsByIdPut(id, document, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public apiDocumentsGet(options?: any) {
        return DocumentsApiFp(this.configuration).apiDocumentsGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} [document] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public apiDocumentsPost(document?: UploadDocumentRequest, options?: any) {
        return DocumentsApiFp(this.configuration).apiDocumentsPost(document, options)(this.fetch, this.basePath);
    }

}

/**
 * SearchApi - fetch parameter creator
 * @export
 */
export const SearchApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array&lt;number&gt;} [tagIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSearchGet(tagIds?: Array<number>, options: any = {}): FetchArgs {
            const localVarPath = `/api/Search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = object_assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Bearer", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (tagIds) {
                localVarQueryParameter['tagIds'] = tagIds;
            }

            localVarUrlObj.query = object_assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = object_assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array&lt;number&gt;} [tagIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSearchGet(tagIds?: Array<number>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SearchResponse> {
            const localVarFetchArgs = SearchApiFetchParamCreator(configuration).apiSearchGet(tagIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Array&lt;number&gt;} [tagIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSearchGet(tagIds?: Array<number>, options?: any) {
            return SearchApiFp(configuration).apiSearchGet(tagIds, options)(fetch, basePath);
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * 
     * @param {} [tagIds] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public apiSearchGet(tagIds?: Array<number>, options?: any) {
        return SearchApiFp(this.configuration).apiSearchGet(tagIds, options)(this.fetch, this.basePath);
    }

}

/**
 * TagsApi - fetch parameter creator
 * @export
 */
export const TagsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/Tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = object_assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Bearer", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = object_assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = object_assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateTagRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsPost(request?: CreateTagRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = object_assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Bearer", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = object_assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = object_assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(request || {});

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TagResponse> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).apiTagsGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CreateTagRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsPost(request?: CreateTagRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TagResponse> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).apiTagsPost(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsGet(options?: any) {
            return TagsApiFp(configuration).apiTagsGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {CreateTagRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsPost(request?: CreateTagRequest, options?: any) {
            return TagsApiFp(configuration).apiTagsPost(request, options)(fetch, basePath);
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public apiTagsGet(options?: any) {
        return TagsApiFp(this.configuration).apiTagsGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public apiTagsPost(request?: CreateTagRequest, options?: any) {
        return TagsApiFp(this.configuration).apiTagsPost(request, options)(this.fetch, this.basePath);
    }

}

